export const GREEK_ALPHABET = [
  'alpha',
  'beta',
  'gamma',
  'delta',
  'epsilon',
  'zeta',
  'eta',
  'theta',
  'iota',
  'kappa',
  'lambda',
  'mu',
  'nu',
  'xi',
  'omicron',
  'pi',
  'rho',
  'sigma',
  'tau',
  'upsilon',
  'phi',
  'chi',
  'psi',
  'omega',
] as const;

export interface TagGenerationResult {
  tag: string;
  wasAutoGenerated: boolean;
  wasConflictResolved: boolean;
  originalTag?: string;
}

export class TagGenerator {
  private existingTags: Set<string>;

  constructor(existingTags: string[]) {
    this.existingTags = new Set(existingTags.map((tag) => tag.toLowerCase()));
  }

  /**
   * Generate a unique tag using Greek alphabet rotation
   */
  public generateUniqueTag(): TagGenerationResult {
    // Try basic Greek alphabet first
    for (const letter of GREEK_ALPHABET) {
      if (!this.existingTags.has(letter)) {
        return {
          tag: letter,
          wasAutoGenerated: true,
          wasConflictResolved: false,
        };
      }
    }

    // Try with incrementing numbers
    let round = 1;
    while (round <= 1000) {
      // Safety limit to prevent infinite loops
      for (const letter of GREEK_ALPHABET) {
        const candidateTag = `${letter}-${round}`;
        if (!this.existingTags.has(candidateTag)) {
          return {
            tag: candidateTag,
            wasAutoGenerated: true,
            wasConflictResolved: false,
          };
        }
      }
      round++;
    }

    // Fallback to timestamp-based tag (extremely unlikely scenario)
    const timestampTag = `tag-${Date.now()}`;
    return {
      tag: timestampTag,
      wasAutoGenerated: true,
      wasConflictResolved: false,
    };
  }

  /**
   * Resolve tag conflicts by appending incrementing numbers
   */
  public resolveTagConflict(originalTag: string): TagGenerationResult {
    const normalizedOriginal = originalTag.toLowerCase();

    // If original tag is available, return it
    if (!this.existingTags.has(normalizedOriginal)) {
      return {
        tag: originalTag,
        wasAutoGenerated: false,
        wasConflictResolved: false,
      };
    }

    // Try incrementing numbers
    let counter = 1;
    while (counter <= 10000) {
      // Safety limit
      const candidateTag = `${originalTag}-${counter}`;
      const normalizedCandidate = candidateTag.toLowerCase();

      if (!this.existingTags.has(normalizedCandidate)) {
        return {
          tag: candidateTag,
          wasAutoGenerated: false,
          wasConflictResolved: true,
          originalTag,
        };
      }
      counter++;
    }

    // Fallback to timestamp-based tag (extremely unlikely scenario)
    const timestampTag = `${originalTag}-${Date.now()}`;
    return {
      tag: timestampTag,
      wasAutoGenerated: false,
      wasConflictResolved: true,
      originalTag,
    };
  }

  /**
   * Get a unique tag - either auto-generate or resolve conflict
   */
  public getUniqueTag(requestedTag?: string): TagGenerationResult {
    if (!requestedTag || requestedTag.trim() === '') {
      return this.generateUniqueTag();
    }

    return this.resolveTagConflict(requestedTag.trim());
  }
}
